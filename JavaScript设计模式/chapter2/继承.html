<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>1.17</title>
</head>
<body>

	<script type="text/javascript">
	/*
		类式继承的缺点：
			1.子类.prototype 是通过对父类实例化来继承父类 
			  若父类中的公有属性是引用类型 改变该属性会影响其他的子类
			2.无法向父类传参
		构造函数继承的缺点：
			父类的原型方法不被子类继承

	*/ 
		// 组合继承
		// 声明父类
		function SuperClass(name) {
			// 值类型共有属性
			this.name = name;
			// 引用类型共有属性
			this.books = ["JavaScript", "html", "css"];
		}
		// 父类原型共有方法
		SuperClass.prototype.getName = function() {
			console.log(this.name);
		};
		// 声明子类
		function SubClass(name, time) {
			// 构造函数式继承父类name属性
			SuperClass.call(this, name);
			// 子类中新增共有属性
			this.time = time;
		}
		// 类式继承 子类原型继承父类
		SubClass.prototype = new SuperClass();
		// 子类原型方法
		SubClass.prototype.getTime = function () {
			console.log(this.time);
		}

		var instance1 = new SubClass('js book', 2014);
		instance1.books.push('设计模式');
		console.log(instance1.books);
		instance1.getName()
		instance1.getTime()

		var instance2 = new SubClass("css世界", 2018)
		console.log(instance2.books);
		instance2.getName()
		instance2.getTime()


		
	</script>
</body>
</html>