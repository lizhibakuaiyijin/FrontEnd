<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8">
	<title>1.16</title>
</head>
<body>
	<script type="text/javascript">
		// 私有属性与私有方法，特权方法，对象公有属性和对象共有方法，构造器
		var Book = function (id, name, price) {
			// 私有属性
			var num = 1;
			// 私有方法
			function checkId() {
				
			};
			// 特权方法
			this.getName = function () {
				
			}
			this.getPrice = function () {
				
			}
			this.setName = function () {
				
			}
			this.setPrice = function () {
				
			}
			// 对象公有属性
			this.id = id;
			// 对象公有方法
			this.copy = function () {
				
			}
			// 构造器
			this.setName(name);
			this.setPrice(price)
		}
		// 类静态公有属性（对象不能访问）
		Book.isChinese = true;
		// 类静态公有方法（对象不能访问）
		Book.resetTime = function () {
			console.log('new Time')
		}
		Book.prototype = {
			// 公有属性
			isJSBook : false,
			// 公有方法
			display : function function_name() {
				
			}
		}
		// 通过 new 关键字创建的对象实质是对新对象this的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法定义的属性和方法是不会添加到新创建的对象上去的。因此要想在新创建的对象中使用isChinese就得通过Book类使用而不能通过this，如Book.isChinese,而类的原型prototype上定义的属性在新的对象里就可以直接使用，这是因为新对象的prototype和类的prototype指向的是同一个对象。

		var b = new Book(1, 'JS高级编程', 32);
		console.log(b.num);  // 类的私有属性  访问不到
		console.log(b.isJSBook);  // 类的公有属性
		console.log(b.id); 
		console.log(b.isChinese); // 静态公有属性 访问不到
		console.log(Book.isChinese)
		Book.resetTime()

	</script>
</body>
</html>