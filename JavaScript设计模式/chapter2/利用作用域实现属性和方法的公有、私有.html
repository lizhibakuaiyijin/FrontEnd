<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8">
	<title>1.16</title>
</head>
<body>
	<div>
		由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外部是访问不到的，通过此特性即可创建类的私有变量以及私有方法。然而在函数内部通过this创建的属性和方法，在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到。因此通过this创建的属性可以看作是对象共有属性和对象共有方法，，而通过this创建的方法， 不但可以访问这些对象的共有属性和共有方法，而且还能访问到类（创建时）或对象自身的私有属性和方法，由于这些方法权利比较大，所以我们又将它看作特权方法。在对象创建时通过使用这些特权方法我们可以初始化实例对象的一些属性，因以看作是类的构造器。
	</div>
	<script type="text/javascript">
		// 私有属性与私有方法，特权方法，对象公有属性和对象共有方法，构造器
		var Book = function (id, name, price) {
			// 私有属性
			var num = 1;
			// 私有方法
			function checkId() {
				
			};
			// 特权方法
			this.getNumber = function () {
				console.log(num)
				num ++;
			}
			this.getName = function () {
				
			}
			this.getPrice = function () {
				
			}
			this.setName = function () {
				
			}
			this.setPrice = function () {
				
			}
			// 对象公有属性
			this.id = id;
			// 对象公有方法
			this.copy = function () {
				
			}
			// 构造器
			this.setName(name);
			this.setPrice(price)
		}
		// 类静态公有属性（对象不能访问）
		Book.isChinese = true;
		// 类静态公有方法（对象不能访问）
		Book.resetTime = function () {
			console.log('new Time')
		}
		Book.prototype = {
			// 公有属性
			isJSBook : false,
			// 公有方法
			display : function function_name() {
				
			}
		}
		// 通过 new 关键字创建的对象实质是对新对象this的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法定义的属性和方法是不会添加到新创建的对象上去的。因此要想在新创建的对象中使用isChinese就得通过Book类使用而不能通过this，如Book.isChinese,而类的原型prototype上定义的属性在新的对象里就可以直接使用，这是因为新对象的prototype和类的prototype指向的是同一个对象。

		var a = new Book(1, 'JS高级编程', 32);
		var b = new Book(2, 'JS高级编程', 31);
		a.getNumber();
		
		a.getNumber();
		b.getNumber();

		console.log(b.num);  // 类的私有属性  访问不到
		console.log(b.isJSBook);  // 类的公有属性
		console.log(b.id); 
		console.log(b.isChinese); // 静态公有属性 访问不到
		console.log(Book.isChinese)
		Book.resetTime()

	</script>
</body>
</html>